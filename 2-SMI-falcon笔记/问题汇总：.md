
Bulk_test阅读中积累的关于C语言或操作系统相关的问题：


1.	内存管理：
(1)	内联函数inline——优化函数栈stack开销:
    [为什么栈相对于堆很小(c/c++，x86-64)](https://www.zhihu.com/question/59238963):
1)	分工原则？
a.	栈stack(栈顶一般留存在cpu_reg和cache中，线程独立-每个线程都有自己stack，若线程成百上千(事实上如此)则必须限制stack size)为函数调用服务，承担生命周期很短、尺寸很小的临时对象的存储责任且其由编译器自动维护(FILO自动分配和回收)；
b.	堆heap负责存储生命周期由程序员自主维护，以及尺寸极大的(eg明显超过栈的尺寸)对象/数据，进程内公用。
2)	栈特点与作用：
a.	[函数调用](https://segmentfault.com/a/1190000007977460)(提供保存、恢复等操作)，局部变量申请，函数参数传递；（[程序的内存布局——函数调用栈](https://blog.csdn.net/yang_yulei/article/details/45795591)）
b.	栈帧存储数据有局部变量，函数返回地址与函数参数——存储的数据量少使得栈本身很小内存即可；
c.	user无法opt，由OS与编译器决定。
d.	线性管理：
3)	堆：
a.	User可opt(无关OS与编译器)——存储任何数据，包括视音频数据库等 ；
b.	内存池管理Memory pool：
a)	mempool，区别于new 与malloc(内存块大小不定——容易产生内存碎片)
b)	Design mempool：	
4)	

(2)	[Linux2.x内核对内存的管理](https://blog.csdn.net/yang_yulei/article/details/24385573):


2.	Process/thread/task管理与调度：
(1)	[临界资源与临界区](https://blog.csdn.net/supreme42/article/details/6834690)
①	仅每次允许一个进程访问，进程间互斥实现对临界资源的共享：
1)	硬件：打印机磁带机等；
2)	软件：消息缓冲队列，变量，数组，缓冲区等；
②	进程中访问临界资源的代码称为临界区(别名管程)，检查——是否访问——实现互斥：
(2)	IPC-inter process communication进程通信方式(同一进程的不同线程进行通信)：
①	Linux-IPC(主要6种 pipe，signal，message-queue，share-memory，semaphore，socket)：
1)	Message queue：
2)	[消息队列MQ](https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)（缓冲区）（生[产者与消费者](https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98)）：
a.	基本模式：MQ为空——消费者不可取/唤醒生产者，为满——生产者不可入/唤醒消费者；
b.	[Linux_C实现](https://blog.csdn.net/xyisv/article/details/80467668)(注意与win_c区别)；
c.	特点：[异步|松耦合|分布式|可靠](https://github.com/jasonGeng88/blog/blob/master/201705/MQ.md)；
3)	[信号量semaphore](https://blog.csdn.net/ljianhui/article/details/10243617)：一种特殊的变量，实际为一个存储单元——（控制进程状态/代表某一资源），表现形式为一个整形(信号量S)与一个队列。
a.	PV(通过/释放)操作，原子操作——实现互斥/同步：
a)	P——（sem-1）——(sem>0?)——continue(进程继续执行)/idle(睡眠状态);
b)	V——（sem+1）——(sem<=0?)——wakeup(唤醒等待进程)/idle(睡眠状态);
c)	

②	[CreateThread步骤](https://blog.csdn.net/u012877472/article/details/49721653)
1)	在内核对象中分配一个线程标识/句柄handle([线程ID与线程句柄](http://blog.sina.com.cn/s/blog_4e0494e00100jig5.html)：系统全局与进程局部？)，可供管理，由CreateThread返回；
③	
(3)	进程process，线程thread，任务task，在不同操作系统中的不同含义：
①	Windows：明确区分process与thread(一个process下有多个thread)，
1)	
②	Linux：无明确process与thread概念区别，即只有process(略像win下thread)。
(4)	
①	Linux：
3.	文件与设备管理：
(1)	
4.	内核kernel技术：
(1)	POSIX-portable OSinterface of Unix 可移植操作系统接口：Unix标准，跨平台。
